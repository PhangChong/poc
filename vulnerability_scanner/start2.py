import tkinter as tk
from tkinter import filedialog, messagebox, Toplevel, Checkbutton, IntVar

import threading
import urllib3
from Modules import proxies, Fofa
from Config import start_vulner_list
from Config.Default_value import serverj_default_value_key, fofa_default_value_email, \
    fofa_default_value_key, fofa_default_value_search, fofa_default_value_size, \
    proxies_default_value_port, proxies_default_value_ip, icon_v
from Common.LoadJson import loadJson

from Config.Vulnerability_Detection import detection

# 禁用安全请求警告
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class VulnDetectionApp:
    def __init__(self, root):
        self.proxies_default_value_ip = proxies_default_value_ip
        self.proxies_default_value_port = proxies_default_value_port
        self.serverj_default_value = serverj_default_value_key
        self.fofa_default_value_email = fofa_default_value_email
        self.fofa_default_value_key = fofa_default_value_key
        self.fofa_default_value_search = fofa_default_value_search
        self.fofa_default_value_size = fofa_default_value_size
        self.root = root
        self.root.title("漏洞检测程序")
        self.root.geometry("1000x800")
        self.root.iconbitmap(icon_v("home"))
        self.vulnerabilities_l = start_vulner_list.vulnerabilities
        self.vars = []  # 存储选择框的变量

        self.create_menu()
        self.create_input_text()
        self.create_output_text()
        self.create_variables()

    def create_menu(self):
        """创建菜单"""
        menu_bar = tk.Menu(self.root)
        self.root.config(menu=menu_bar)

        file_menu = tk.Menu(menu_bar, tearoff=0)
        file_menu.add_command(label="选择文件", command=self.select_file)
        file_menu.add_command(label="保存输出结果", command=self.save_output)
        file_menu.add_separator()
        file_menu.add_command(label="退出", command=self.root.quit)
        menu_bar.add_cascade(label="菜单", menu=file_menu)

        vulnerabilities_menu = tk.Menu(menu_bar, tearoff=0)
        vulnerabilities_menu.add_command(label="漏洞库", command=self.open_vulnerabilities_window)
        menu_bar.add_cascade(label="漏洞", menu=vulnerabilities_menu)

        peizi_menu = tk.Menu(menu_bar, tearoff=0)
        peizi_menu.add_command(label="代理配置", command=self.open_Peizi_proxy_window)
        peizi_menu.add_command(label="Server酱", command=self.open_Peizi_Serverj_window)
        peizi_menu.add_command(label="测试", command=self.open_Peizi_test_window)
        menu_bar.add_cascade(label="配置", menu=peizi_menu)

        cyberspace_menu = tk.Menu(menu_bar, tearoff=0)
        cyberspace_menu.add_command(label="FOFA", command=self.open_Fofa_window)
        cyberspace_menu.add_command(label="Hunter鹰图", command=self.open_Hunter_window)
        menu_bar.add_cascade(label="网络空间测绘", menu=cyberspace_menu)

        help_menu = tk.Menu(menu_bar, tearoff=0)
        help_menu.add_command(label="新变化", command=self.open_UpdateLog_window)
        menu_bar.add_cascade(label="帮助", menu=help_menu)

    def create_input_text(self):
        """创建输入文本框"""
        self.input_frame = tk.Frame(self.root)
        self.input_frame.pack(pady=10, padx=10, fill=tk.X)  # 添加 fill=tk.X 以使框架水平填充

        self.file_label = tk.Label(self.input_frame, text="文件路径：")
        self.file_label.grid(row=0, column=0, padx=(0, 5))  # 放置在第0行第0列，右侧留有一些空白

        self.file_entry = tk.Entry(self.input_frame, width=30)  # 设置输入框的长度为30
        self.file_entry.grid(row=0, column=1)  # 放置在第0行第1列

        # 创建一个新的框架来包含检测和停止按钮
        button_subframe = tk.Frame(self.input_frame)
        button_subframe.grid(row=0, column=2, padx=(10, 0))  # 放置在第0行第2列，左侧留有一些空白

        self.detect_button = tk.Button(button_subframe, text="检测", command=self.detect_vulnerabilities, width=10)
        self.detect_button.grid(row=0, column=0, padx=(0, 5))  # 放置在第0行第0列

        self.stop_button = tk.Button(button_subframe, text="停止", command=self.stop_detection, width=10)
        self.stop_button.grid(row=0, column=1)  # 放置在第0行第1列

    def create_output_text(self):
        """创建输出文本框"""
        output_frame = tk.Frame(self.root)
        output_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        self.output_text = tk.Text(output_frame, bg="black", fg="white", state=tk.DISABLED, font=("Helvetica", 14))
        self.output_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # 添加垂直滚动条
        scrollbar = tk.Scrollbar(output_frame, command=self.output_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.output_text.configure(yscrollcommand=scrollbar.set)

        self.output_text.tag_configure("red", foreground="#FF0000", font=("Helvetica", 12, "bold"))
        self.output_text.tag_configure("green", foreground="#00FF00", font=("Helvetica", 12))
        self.output_text.tag_configure("yellow", foreground="yellow", font=("Helvetica", 12))

    def create_variables(self):
        """创建变量"""
        self.proxies_var = IntVar()
        self.proxies_var.set(0)

        self.serverj_var = IntVar()
        self.serverj_var.set(0)

        self.stop_detection_flag = False

    def select_file(self):
        """选择文件"""
        file_path = filedialog.askopenfilename(filetypes=[("Text Files", "*.txt")])
        self.file_entry.delete(0, tk.END)
        self.file_entry.insert(tk.END, file_path)

    def detect_vulnerabilities(self):
        """检测漏洞"""
        file_path = self.file_entry.get().strip()
        if not file_path:
            messagebox.showerror("错误", "请输入文件路径")
            return

        # 检查是否选择了漏洞
        if not self.vars:
            messagebox.showerror("错误", "请选择漏洞")
            return

        with open(file_path, "r") as file:
            urls = file.read().splitlines()
        selected_vulnerabilities = [self.vulnerabilities_l[index] for index, var in enumerate(self.vars) if
                                    var.get() == 1]

        # 其他检测代码...
        self.output_text.config(state=tk.NORMAL)
        self.output_text.delete("1.0", tk.END)
        self.output_text.config(state=tk.DISABLED)
        self.stop_detection_flag = False
        detection_thread = threading.Thread(target=self.perform_detection, args=(urls, selected_vulnerabilities))
        detection_thread.start()

    def perform_detection(self, urls, vulnerabilities):
        """执行漏洞检测"""
        # 代理启动开关
        if self.proxies_var.get() == 1:
            self.proxies = proxies.update_proxies(self.proxies_default_value_ip, self.proxies_default_value_port)
            print("已启动代理", self.proxies)
        else:
            self.proxies = None
        # server酱启动开关
        if self.serverj_var.get() == 1:
            serverJ_key = self.serverj_default_value
            print("server酱启动开关", serverJ_key)
        else:
            serverJ_key = " "

        for url in urls:
            if self.stop_detection_flag:
                break
            print("链接：", url)
            for vulnerability in vulnerabilities:
                detection(vulnerability, url, self.proxies, self.append_to_output, serverJ_key)
        if self.stop_detection_flag:
            self.append_to_output("已停止！！！！", "yellow")

    def save_output(self):
        """保存输出结果"""
        file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt")])
        if file_path:
            with open(file_path, "w") as file:
                output_text = self.output_text.get("1.0", tk.END)
                file.write(output_text)

    def stop_detection(self):
        """停止检测"""
        self.stop_detection_flag = True
        self.append_to_output("已停止！！！！", "yellow")

    '''-------配置------------------------'''

    def open_Peizi_proxy_window(self):
        """打开配置窗口"""
        if hasattr(self, 'Peizi_proxy_window') and self.Peizi_proxy_window.winfo_exists():
            # 如果窗口已经存在，则将其带到前台
            self.Peizi_proxy_window.lift()
        else:
            # 如果窗口不存在，则创建一个新的配置窗口
            self.Peizi_proxy_window = Toplevel(self.root)
            self.Peizi_proxy_window.title("代理配置")
            self.Peizi_proxy_window.iconbitmap(icon_v("serverj"))
            canvas = tk.Canvas(self.Peizi_proxy_window, width=400, height=300)
            canvas.pack(fill=tk.BOTH, expand=True)

            # 代理设置框架
            proxy_frame = tk.Frame(canvas)
            proxy_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            proxy_frame.grid_rowconfigure(5, weight=1)  # 添加一个空行以使得代理设置框架的布局能够扩展

            # 代理设置部分
            proxy_label = tk.Label(proxy_frame, text="开启代理：")
            proxy_label.grid(row=1, column=0, sticky=tk.W)
            proxy_checkbox = Checkbutton(proxy_frame, text=" ", variable=self.proxies_var)
            proxy_checkbox.grid(row=1, column=1, sticky=tk.W)

            ip_label = tk.Label(proxy_frame, text="IP地址：")
            ip_label.grid(row=2, column=0, sticky=tk.W)
            self.proxy_entry_ip = tk.Entry(proxy_frame)
            self.proxy_entry_ip.grid(row=2, column=1, sticky=tk.W)
            self.proxy_entry_ip.insert(0, self.proxies_default_value_ip)

            port_label = tk.Label(proxy_frame, text="端口：")
            port_label.grid(row=3, column=0, sticky=tk.W)
            self.proxy_entry_port = tk.Entry(proxy_frame)
            self.proxy_entry_port.grid(row=3, column=1, sticky=tk.W)
            self.proxy_entry_port.insert(0, self.proxies_default_value_port)

            submit_proxy_button = tk.Button(proxy_frame, text="保存", command=self.submit_proxy_text)
            submit_proxy_button.grid(row=4, column=0, columnspan=2, sticky=tk.W, pady=5)
            self.display_port_label = tk.Label(proxy_frame, text="")
            self.display_port_label.grid(row=5, column=0, columnspan=2, sticky=tk.W)

            canvas.create_window((0, 0), window=proxy_frame, anchor="nw")

    def open_Peizi_Serverj_window(self):
        """打开配置窗口"""
        if hasattr(self, 'Peizi_Serverj_window') and self.Peizi_Serverj_window.winfo_exists():
            # 如果窗口已经存在，则将其带到前台
            self.Peizi_Serverj_window.lift()
        else:
            # 如果窗口不存在，则创建一个新的配置窗口
            self.Peizi_Serverj_window = Toplevel(self.root)
            self.Peizi_Serverj_window.title("Server酱配置")
            self.Peizi_Serverj_window.iconbitmap(icon_v("serverj"))
            canvas = tk.Canvas(self.Peizi_Serverj_window, width=400, height=300)
            canvas.pack(fill=tk.BOTH, expand=True)

            # Server酱设置框架
            serverj_frame = tk.Frame(canvas)
            serverj_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            serverj_frame.grid_rowconfigure(5, weight=1)  # 添加一个空行以使得Server酱设置框架的布局能够扩展

            # Server酱设置部分
            serverj_label = tk.Label(serverj_frame, text="开启Server酱：")
            serverj_label.grid(row=1, column=0, sticky=tk.W)
            serverj_checkbox = Checkbutton(serverj_frame, text=" ", variable=self.serverj_var)
            serverj_checkbox.grid(row=1, column=1, sticky=tk.W)

            sjkey_label = tk.Label(serverj_frame, text="Server酱 Key：")
            sjkey_label.grid(row=2, column=0, sticky=tk.W)
            self.SJKey_entry = tk.Entry(serverj_frame)
            self.SJKey_entry.grid(row=2, column=1, sticky=tk.W)
            self.SJKey_entry.insert(0, self.serverj_default_value)

            submit_SJkey_button = tk.Button(serverj_frame, text="保存", command=self.submit_SJKey_text)
            submit_SJkey_button.grid(row=3, column=0, columnspan=2, sticky=tk.W, pady=5)
            self.display_SJKey_label = tk.Label(serverj_frame, text="")
            self.display_SJKey_label.grid(row=4, column=0, columnspan=2, sticky=tk.W)

            canvas.create_window((0, 0), window=serverj_frame, anchor="nw")

    def open_Peizi_test_window(self):
        """打开配置窗口"""
        if hasattr(self, 'Peizi_test_window') and self.Peizi_test_window.winfo_exists():
            # 如果窗口已经存在，则将其带到前台
            self.Peizi_test_window.lift()
        else:
            # 如果窗口不存在，则创建一个新的配置窗口
            self.Peizi_test_window = Toplevel(self.root)
            self.Peizi_test_window.title("测试：Server酱及代理配置")
            self.Peizi_test_window.iconbitmap(icon_v("home"))
            canvas = tk.Canvas(self.Peizi_test_window, width=400, height=300)
            canvas.pack(fill=tk.BOTH, expand=True)

            # 代理设置框架
            proxy_frame = tk.Frame(canvas)
            proxy_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            proxy_frame.grid_rowconfigure(5, weight=1)  # 添加一个空行以使得代理设置框架的布局能够扩展

            # 代理设置部分
            proxy_label = tk.Label(proxy_frame, text="开启代理：")
            proxy_label.grid(row=1, column=0, sticky=tk.W)
            proxy_checkbox = Checkbutton(proxy_frame, text=" ", variable=self.proxies_var)
            proxy_checkbox.grid(row=1, column=1, sticky=tk.W)

            ip_label = tk.Label(proxy_frame, text="IP地址：")
            ip_label.grid(row=2, column=0, sticky=tk.W)
            self.proxy_entry_ip = tk.Entry(proxy_frame)
            self.proxy_entry_ip.grid(row=2, column=1, sticky=tk.W)
            self.proxy_entry_ip.insert(0, self.proxies_default_value_ip)

            port_label = tk.Label(proxy_frame, text="端口：")
            port_label.grid(row=3, column=0, sticky=tk.W)
            self.proxy_entry_port = tk.Entry(proxy_frame)
            self.proxy_entry_port.grid(row=3, column=1, sticky=tk.W)
            self.proxy_entry_port.insert(0, self.proxies_default_value_port)

            submit_proxy_button = tk.Button(proxy_frame, text="保存", command=self.submit_proxy_text)
            submit_proxy_button.grid(row=4, column=0, columnspan=2, sticky=tk.W, pady=5)
            self.display_port_label = tk.Label(proxy_frame, text="")
            self.display_port_label.grid(row=5, column=0, columnspan=2, sticky=tk.W)

            # Server酱设置框架
            serverj_frame = tk.Frame(canvas)
            serverj_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            serverj_frame.grid_rowconfigure(5, weight=1)  # 添加一个空行以使得Server酱设置框架的布局能够扩展

            # Server酱设置部分
            serverj_label = tk.Label(serverj_frame, text="开启Server酱：")
            serverj_label.grid(row=1, column=0, sticky=tk.W)
            serverj_checkbox = Checkbutton(serverj_frame, text=" ", variable=self.serverj_var)
            serverj_checkbox.grid(row=1, column=1, sticky=tk.W)

            sjkey_label = tk.Label(serverj_frame, text="Server酱 Key：")
            sjkey_label.grid(row=2, column=0, sticky=tk.W)
            self.SJKey_entry = tk.Entry(serverj_frame)
            self.SJKey_entry.grid(row=2, column=1, sticky=tk.W)
            self.SJKey_entry.insert(0, self.serverj_default_value)

            submit_SJkey_button = tk.Button(serverj_frame, text="保存", command=self.submit_SJKey_text)
            submit_SJkey_button.grid(row=3, column=0, columnspan=2, sticky=tk.W, pady=5)
            self.display_SJKey_label = tk.Label(serverj_frame, text="")
            self.display_SJKey_label.grid(row=4, column=0, columnspan=2, sticky=tk.W)

            canvas.create_window((0, 0), window=proxy_frame, anchor="nw")
            canvas.create_window((0, 150), window=serverj_frame, anchor="nw")

    '''-------网络空间------------------------'''

    def open_Fofa_window(self):
        if hasattr(self, 'Fofa_window') and self.Fofa_window.winfo_exists():
            # 如果窗口已经存在，则将其带到前台
            self.Fofa_window.lift()
        else:
            # 如果窗口不存在，则创建一个新的FOFA窗口
            self.Fofa_window = Toplevel(self.root)
            self.Fofa_window.title("FOFA")
            # vulnerabilities_window.geometry("400x300")
            self.Fofa_window.iconbitmap(icon_v("fofa"))
            canvas = tk.Canvas(self.Fofa_window, width=400, height=300)
            canvas.pack(fill=tk.BOTH, expand=True)

            # 创建一个框架，将内容放置在其中
            scrollable_frame = tk.Frame(canvas)
            # ---------------------------------------------------------------------------------------------
            email_label = tk.Label(scrollable_frame, text="Email:")
            email_label.grid(row=0, column=0, sticky=tk.W)
            self.Fofa_entry_email = tk.Entry(scrollable_frame)
            self.Fofa_entry_email.grid(row=0, column=1, sticky=tk.W)
            self.Fofa_entry_email.insert(0, self.fofa_default_value_email)

            key_label = tk.Label(scrollable_frame, text="Key:")
            key_label.grid(row=1, column=0, sticky=tk.W)
            self.Fofa_entry_key = tk.Entry(scrollable_frame)
            self.Fofa_entry_key.grid(row=1, column=1, sticky=tk.W)
            self.Fofa_entry_key.insert(0, self.fofa_default_value_key)

            # 添加提交按钮
            submit_fofa_button = tk.Button(scrollable_frame, text="保存", command=self.submit_Fofa_save_text)
            submit_fofa_button.grid(row=2, column=0, columnspan=2, sticky=tk.W, pady=5)
            self.display_fofa_label = tk.Label(scrollable_frame, text="")
            self.display_fofa_label.grid(row=3, column=0, columnspan=2, sticky=tk.W)

            # -------------下-------------------------------------------------------------------------------
            search_label = tk.Label(scrollable_frame, text="FOFA语法:")
            search_label.grid(row=4, column=0, sticky=tk.W)
            self.Fofa_entry_search = tk.Entry(scrollable_frame)
            self.Fofa_entry_search.grid(row=4, column=1, sticky=tk.W)
            self.Fofa_entry_search.insert(0, self.fofa_default_value_search)

            size_label = tk.Label(scrollable_frame, text="输出数量:")
            size_label.grid(row=5, column=0, sticky=tk.W)
            self.Fofa_entry_size = tk.Entry(scrollable_frame)
            self.Fofa_entry_size.grid(row=5, column=1, sticky=tk.W)
            self.Fofa_entry_size.insert(0, self.fofa_default_value_size)
            # 添加go按钮
            submit_fofa_button_GO = tk.Button(scrollable_frame, text="GO", command=self.submit_Fofa_search_text)
            submit_fofa_button_GO.grid(row=6, column=0, columnspan=2, sticky=tk.W, pady=5)
            self.display_fofa_go_label = tk.Label(scrollable_frame, text="")
            self.display_fofa_go_label.grid(row=7, column=0, columnspan=2, sticky=tk.W)

            # ---------------------------------------------------------------------------------------------

            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

    def open_Hunter_window(self):
        if hasattr(self, 'Hunter_window') and self.Hunter_window.winfo_exists():
            # 如果窗口已经存在，则将其带到前台
            self.Hunter_window.lift()
        else:
            # 如果窗口不存在，则创建一个新的鹰图窗口
            self.Hunter_window = Toplevel(self.root)
            self.Hunter_window.title("鹰图")
            self.Hunter_window.iconbitmap(icon_v("hunter"))
            canvas = tk.Canvas(self.Hunter_window, width=400, height=300)
            canvas.pack(fill=tk.BOTH, expand=True)

            # 创建一个框架，将内容放置在其中
            scrollable_frame = tk.Frame(canvas)

            # ---------------------------------------------------------------------------------------------
            email_label = tk.Label(scrollable_frame, text="已打开窗口，内容还没写")
            email_label.grid(row=0, column=0, sticky=tk.W)
            # ---------------------------------------------------------------------------------------------

            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

    '''-------更新------------------------'''

    def open_UpdateLog_window(self):
        """打开更新窗口"""
        # 检查是否已经存在更新窗口
        existing_windows = self.root.winfo_children()
        for window in existing_windows:
            if isinstance(window, tk.Toplevel) and window.title() == "新变化":
                window.lift()
                return

        # 如果不存在更新窗口，则创建一个新的更新窗口
        UpdateLog_window = tk.Toplevel(self.root)
        UpdateLog_window.title("新变化")
        UpdateLog_window.iconbitmap(icon_v("log"))
        UpdateLog_window.resizable(False, False)
        root.update_idletasks()
        root_width = root.winfo_width()
        root_height = root.winfo_height()
        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()
        x = (screen_width - root_width) // 2
        y = (screen_height - root_height) // 2
        UpdateLog_window.geometry(f"+{x}+{y}")

        # 创建一个 Frame 来包含 Text 和 Scrollbar
        frame = tk.Frame(UpdateLog_window)
        frame.grid(row=0, column=0, sticky="nsew")

        text = loadJson()
        text_widget = tk.Text(frame, wrap="word")
        text_widget.insert(tk.END, text)
        text_widget.config(state=tk.DISABLED)  # 设置为只读
        text_widget.grid(row=0, column=0, sticky="nsew")  # 使用 grid 布局，使文本框填充整个 Frame

        # 添加垂直滚动条并关联
        scrollbar = tk.Scrollbar(frame, command=text_widget.yview)
        scrollbar.grid(row=0, column=1, sticky="ns")  # 使用 grid 布局，使滚动条与文本框对齐
        text_widget.config(yscrollcommand=scrollbar.set)  # 关联滚动条

        # 设置 Frame 的行和列权重，使其可以自动扩展
        UpdateLog_window.grid_rowconfigure(0, weight=1)
        UpdateLog_window.grid_columnconfigure(0, weight=1)

    '''-------提交按钮------------------------'''

    def submit_proxy_text(self):
        """代理配置代理提交按钮点击事件"""
        text1 = self.proxy_entry_port.get()  # 获取输入框中的文本
        self.proxies_default_value_port = text1  # 保存输入框中的文本为默认值
        proxies_port = self.proxies_default_value_port
        text2 = self.proxy_entry_ip.get()  # 获取输入框中的文本
        self.proxies_default_value_ip = text2  # 保存输入框中的文本为默认值
        proxies_ip = self.proxies_default_value_ip
        self.display_port_label.config(text="代理端口成功设置为：" + proxies_ip + ":" + proxies_port)  # 更新Label显示的文本

    def submit_SJKey_text(self):
        """server酱配置key提交按钮点击事件"""
        text = self.SJKey_entry.get()  # 获取输入框中的文本
        self.serverj_default_value = text  # 保存输入框中的文本为默认值
        serverJ_key = self.serverj_default_value
        self.display_SJKey_label.config(text="保存成功，您提交的key为:" + serverJ_key)  # 更新Label显示的文本
        return serverJ_key

    def submit_Fofa_save_text(self):
        """FOFA配置基础数据提交按钮点击事件"""
        text1 = self.Fofa_entry_email.get()
        self.fofa_default_value_email = text1
        text2 = self.Fofa_entry_key.get()
        self.fofa_default_value_key = text2
        self.display_fofa_label.config(text="保存成功")  # 更新Label显示的文本

    def submit_Fofa_search_text(self):
        """FOFA配置fofa查询提交按钮点击事件"""
        text3 = self.Fofa_entry_search.get()
        self.fofa_default_value_search = text3
        text4 = self.Fofa_entry_size.get()
        self.fofa_default_value_size = text4
        output_status = Fofa.fofa(search_query=self.fofa_default_value_search, email=self.fofa_default_value_email,
                                  key=self.fofa_default_value_key, size=self.fofa_default_value_size)
        go_text = output_status  # 获取output-status
        self.display_fofa_go_label.config(text=go_text)  # 更新标签以显示

    '''-------漏洞库------------------------'''

    def open_vulnerabilities_window(self):
        if hasattr(self, 'vulnerabilities_window') and self.vulnerabilities_window.winfo_exists():
            # 如果窗口已经存在，则将其带到前台
            self.vulnerabilities_window.lift()
        else:
            # 如果窗口不存在，则创建一个新的漏洞库窗口
            self.vulnerabilities_window = Toplevel(self.root)
            self.vulnerabilities_window.title("漏洞库")
            self.vulnerabilities_window.geometry("800x600")
            self.vulnerabilities_window.iconbitmap(icon_v("loudongku"))

            canvas = tk.Canvas(self.vulnerabilities_window, width=800, height=600)
            canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            scrollbar = tk.Scrollbar(self.vulnerabilities_window, orient=tk.VERTICAL, command=canvas.yview)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            canvas.configure(yscrollcommand=scrollbar.set)

            scrollable_frame = tk.Frame(canvas)
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

            select_all_checkbox_var = tk.IntVar()
            select_all_checkbox = tk.Checkbutton(scrollable_frame, text="全选", variable=select_all_checkbox_var,
                                                 command=lambda: self.select_all_vulnerabilities(
                                                     select_all_checkbox_var))
            select_all_checkbox.pack(anchor=tk.W)

            proxy_checkbox = tk.Checkbutton(scrollable_frame, text="开启代理", variable=self.proxies_var)
            proxy_checkbox.pack(anchor=tk.W)

            serverj_checkbox = tk.Checkbutton(scrollable_frame, text="开启Server酱", variable=self.serverj_var)
            serverj_checkbox.pack(anchor=tk.W)

            detect_button = tk.Button(scrollable_frame, text="确定并开始",
                                      command=self.detect_vulnerabilities_from_library_and_close)
            detect_button.pack(anchor=tk.W, padx=5)

            # 清空已存在的变量列表
            self.vars.clear()

            for index, vulnerability in enumerate(self.vulnerabilities_l):
                var = tk.IntVar()
                self.vars.append(var)
                checkbox = tk.Checkbutton(scrollable_frame, text=vulnerability, variable=var)
                checkbox.pack(anchor=tk.W)

            def on_configure(event):
                canvas.configure(scrollregion=canvas.bbox("all"))

            scrollable_frame.bind("<Configure>", on_configure)
            canvas.bind("<Configure>", on_configure)

            canvas.bind_all("<MouseWheel>", lambda e: canvas.yview_scroll(-1 * int((e.delta / 120)), "units"))

    def select_all_vulnerabilities(self, select_all_var):
        """全选漏洞"""
        select_all_state = select_all_var.get()
        for var in self.vars:
            var.set(select_all_state)

    def detect_vulnerabilities_from_library(self):
        """从库中检测漏洞"""
        file_path = self.file_entry.get().strip()
        if not file_path:
            messagebox.showerror("错误", "请输入文件路径")
            return

        with open(file_path, "r") as file:
            urls = file.read().splitlines()

        selected_vulnerabilities = []
        for index, var in enumerate(self.vars):
            if var.get() == 1 and index < len(self.vulnerabilities_l):
                selected_vulnerabilities.append(self.vulnerabilities_l[index])
        print("选中的漏洞：", selected_vulnerabilities)  # 添加这行打印语句来检查选中的漏洞

        self.output_text.config(state=tk.NORMAL)
        self.output_text.delete("1.0", tk.END)
        self.output_text.config(state=tk.DISABLED)

        self.stop_detection_flag = False

        detection_thread = threading.Thread(target=self.perform_detection, args=(urls, selected_vulnerabilities))
        detection_thread.start()

    def detect_vulnerabilities_from_library_and_close(self):
        """从库中检测漏洞并关闭窗口"""
        self.detect_vulnerabilities_from_library()  # 调用检测漏洞的方法
        self.vulnerabilities_window.destroy()  # 关闭漏洞库窗口

    def append_to_output(self, text, tag=None):
        """将文本添加到输出框"""
        if self.stop_detection_flag == True:
            print("停了")
            text = "已停止！！！！"
            tag = "yellow"
        else:
            pass
        self.output_text.config(state=tk.NORMAL)
        if tag:
            self.output_text.insert(tk.END, text + "\n", tag)
        else:
            self.output_text.insert(tk.END, text + "\n")
        self.output_text.config(state=tk.DISABLED)
        self.output_text.see(tk.END)


# 创建根窗口
root = tk.Tk()
# 创建应用实例
app = VulnDetectionApp(root)
# 进入主事件循环
root.mainloop()
